<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>5 Monkeys</title><link href="http://labs.5monkeys.se/" rel="alternate"></link><link href="http://labs.5monkeys.se/feeds/jonas-lundberg.atom.xml" rel="self"></link><id>http://labs.5monkeys.se/</id><updated>2012-11-17T12:00:00+01:00</updated><entry><title>DjangoÂ Viewlet</title><link href="http://labs.5monkeys.se/django-viewlet.html" rel="alternate"></link><updated>2012-11-17T12:00:00+01:00</updated><author><name>Jonas Lundberg</name></author><id>tag:labs.5monkeys.se,2012-11-17:django-viewlet.html</id><summary type="html">&lt;p&gt;&lt;em&gt;(Draft)&lt;/em&gt;&lt;/p&gt;
&lt;div class="section" id="find-and-analyze-your-problem"&gt;
&lt;h2&gt;Find and analyze your&amp;nbsp;problem&lt;/h2&gt;
&lt;p&gt;A common problem when building web sites is that they tend to load slower and slower when the user base starts to grow,
and the requests/sec has to reach the next&amp;nbsp;level.&lt;/p&gt;
&lt;p&gt;These slow responses often depend on third party resources like a database or external service api&amp;#8217;s.
A great solution to improve page speed is to start caching slow parts of your logic and&amp;nbsp;context.&lt;/p&gt;
&lt;p&gt;But, before doing this you should always try to optimize the code that are about to be cached, you don&amp;#8217;t want to &amp;quot;hide&amp;quot; dirty&amp;nbsp;code.&lt;/p&gt;
&lt;p&gt;A few simple&amp;nbsp;tips:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;try to decrease number of database&amp;nbsp;queries&lt;/li&gt;
&lt;li&gt;make sure your slow or common queries are well&amp;nbsp;indexed&lt;/li&gt;
&lt;li&gt;if using Django&amp;#8217;s &lt;span class="caps"&gt;ORM&lt;/span&gt;, use .values() or .values_list() to fetch less data and decrease&amp;nbsp;cpu/mem.&lt;/li&gt;
&lt;li&gt;fine-tune your resources to line up with your current state of load and&amp;nbsp;memory&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, just by caching your way out doesn&amp;#8217;t mean that your code won&amp;#8217;t be run, and still needs to perform well.
The next step is to figure out &lt;em&gt;what&lt;/em&gt; to cache, &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; to trigger&amp;nbsp;it.&lt;/p&gt;
&lt;div class="section" id="django-s-cache-framework"&gt;
&lt;h3&gt;Django&amp;#8217;s cache&amp;nbsp;framework&lt;/h3&gt;
&lt;p&gt;Django has a few built in solutions for caching, per-site, per-view and template fragment caching.
Per-site and per-view are great tools when your response is anonymous, not containing any user specific stuff
and if your content doesn&amp;#8217;t get updated&amp;nbsp;frequently.&lt;/p&gt;
&lt;p&gt;Since these two will cache your whole response they are quite hard to use on highly dynamic pages. &lt;tt class="docutils literal"&gt;Varnish&lt;/tt&gt; could be a better&amp;nbsp;alternative.&lt;/p&gt;
&lt;p&gt;Template fragment cache on the other hand is a good way to cache parts of your template that are equal to every user like a menu, sidebar, footer&amp;nbsp;etc.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="caching-the-right-stuff"&gt;
&lt;h3&gt;Caching the right&amp;nbsp;stuff&lt;/h3&gt;
&lt;p&gt;This seems to be an easy and good way to solve your problem, but what if the &amp;quot;slow&amp;quot; context variable, like a queryset, already have been executed in the view resulting an even slower page,
since you&amp;#8217;re not caching the slow stuff but actually adding one more resource to the page, the cache it self.
This can be solved by using Django&amp;#8217;s inclusion tags and move context related code from your view to a new tag and wrap that with a cache tag, quite&amp;nbsp;messy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="timeouts"&gt;
&lt;h3&gt;Timeouts&lt;/h3&gt;
&lt;p&gt;Another problem when caching is that you mostly need to set a timeout, for example using the cache tag and set the timeout to 300 seconds,
resulting in your actual code to be re-run every 5 minute. The issue here lies in the re-run part. There&amp;#8217;s no async stuff going on here,
meaning that one of your regular requests will be the one hitting the timeout and causing the code to run once again and re-fill the cache.
A dirty &amp;quot;solution&amp;quot; to this is to brute-force loading your site with a cron-like utility and at a higher frequency than your cache&amp;nbsp;timeouts.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="solving-the-problem"&gt;
&lt;h2&gt;Solving the&amp;nbsp;problem&lt;/h2&gt;
&lt;p&gt;In my opinion, this is not a good way to cache your site, because the speed will vary and the end user will take the hit and trigger your data to&amp;nbsp;reload.&lt;/p&gt;
&lt;p&gt;This is why we wrote &lt;tt class="docutils literal"&gt;Django Viewlet&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;A viewlet is almost like a function based django view, taking a template context as first argument instead of request.
The result of a viewlet is cached and, best of all, able to be refreshed.
It&amp;#8217;s recommended to set your viewlet to never timeout, meaning cache&amp;nbsp;forever.&lt;/p&gt;
&lt;div class="section" id="usage"&gt;
&lt;h3&gt;Usage&lt;/h3&gt;
&lt;p&gt;Place your viewlets in &lt;tt class="docutils literal"&gt;viewlets.py&lt;/tt&gt; or existing &lt;tt class="docutils literal"&gt;views.py&lt;/tt&gt; in your django app&amp;nbsp;directory.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.template.loader&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;render_to_string&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;viewlet&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;viewlet&lt;/span&gt;

&lt;span class="nd"&gt;@viewlet&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello_user&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;render_to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello_user.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can then render the viewlet with the &lt;tt class="docutils literal"&gt;viewlet&lt;/tt&gt; template&amp;nbsp;tag:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{% load viewlets %}
&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;{% viewlet hello_user request.user.username %}&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Normally you&amp;#8217;ll return a rendered template from your viewlet,
but you can also return a context if you need your viewlet template to be rendered on every request, causing the context itself to be cached&amp;nbsp;instead.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="refreshing-viewlets"&gt;
&lt;h3&gt;Refreshing&amp;nbsp;viewlets&lt;/h3&gt;
&lt;p&gt;A cached viewlet can be re-rendered and updated behind the scenes with &lt;tt class="docutils literal"&gt;viewlet.refresh&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;viewlet&lt;/span&gt;
&lt;span class="n"&gt;viewlet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello_user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;monkey&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Content on your site will always get updated by some kind of action, like saving a model or a celery task being executed, modifying some&amp;nbsp;data.&lt;/p&gt;
&lt;p&gt;Try to find these triggers and then hook in your viewlet.refresh&amp;nbsp;there.&lt;/p&gt;
&lt;p&gt;Django signals is a good way of doing this, by either connecting to an existing one like post_save, or dispatching your&amp;nbsp;own.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@viewlet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;product_teaser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_context_object&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Product&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;render_to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;product_teaser.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;product&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;refresh_product_teaser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;viewlet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;product_teaser&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;post_save&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;refresh_product_teaser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Product&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="sum-up"&gt;
&lt;h2&gt;Sum&amp;nbsp;up&lt;/h2&gt;
&lt;p&gt;This will increase your speed, always showing nearly live data and gaining control over the cached parts of your templates.
No more stalling pages or suffering end&amp;nbsp;users.&lt;/p&gt;
&lt;p&gt;Clone, fork or read the full documentation at: &lt;a class="reference external" href="https://github.com/5monkeys/django-viewlet"&gt;https://github.com/5monkeys/django-viewlet&lt;/a&gt;&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://travis-ci.org/5monkeys/django-viewlet"&gt;&lt;img alt="" src="https://travis-ci.org/5monkeys/django-viewlet.png?branch=master" /&gt;&lt;/a&gt;
&lt;/div&gt;
</summary><category term="cache"></category><category term="template"></category><category term="optimizing"></category></entry></feed>